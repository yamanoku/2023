<!DOCTYPE html><html lang="ja"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" type="image/x-icon" href="/favicon.ico"><title>令和最新Route Announcer事情 | yamanoku Advent Calendar 2023</title><meta name="title" content="令和最新Route Announcer事情 | yamanoku Advent Calendar 2023"><meta name="description" content="SPAでの画面遷移のアクセシビリティ改善はつらいよねという話"><meta property="og:type" content="website"><meta property="og:url" content="https://2023.yamanoku.net/2023-12-15/"><meta property="og:title" content="令和最新Route Announcer事情 | yamanoku Advent Calendar 2023"><meta property="og:description" content="SPAでの画面遷移のアクセシビリティ改善はつらいよねという話"><meta property="og:image" content="https://2023.yamanoku.net/ogp-image.png"><meta property="twitter:card" content="summary"><meta property="twitter:url" content="https://2023.yamanoku.net/2023-12-15/"><meta property="twitter:title" content="令和最新Route Announcer事情 | yamanoku Advent Calendar 2023"><meta property="twitter:description" content="SPAでの画面遷移のアクセシビリティ改善はつらいよねという話"><meta property="twitter:image" content="https://2023.yamanoku.net/ogp-image.png"><link rel="stylesheet" href="/_astro/_id_.BSMvvLTT.css">
<style>/*! tailwindcss v4.2.1 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-content:""}}}@layer components{.footnotes{padding-top:var(--spacing-y-rhythm-3,var(--y-rhythm-3));position:relative}.footnotes:before{top:calc(var(--spacing,.25rem) * 0);left:calc(var(--spacing,.25rem) * 0);content:var(--tw-content);background-color:var(--color-y-arcticle-border-color,var(--y-arcticle-border-color));width:100%;height:1px;position:absolute}.footnotes li p{margin:calc(var(--spacing,.25rem) * 0)}}@property --tw-content{syntax:"*";inherits:false;initial-value:""}
</style></head> <body> <header> <div class="inline-flex items-center gap-y-rhythm-1 my-y-rhythm-2 mx-0"> <svg width="48" height="48" viewBox="0 0 246 242" role="img" aria-label="yamanoku"> <path class="fill-[#36465d] dark:fill-y-white-base" fill-rule="evenodd" d="M64,67v54l82,82-46,46v60h56L310,155V96H230l-21,20L160,67H64ZM176,203l-45,46h25L293,113H230l-39,39-31-31H94Z" transform="translate(-64 -67)"></path> </svg> <a href="/" title="トップへ戻る">Advent Calendar 2023</a> </div> </header> <main> <article> <div> <time datetime="2023-12-15">2023-12-15</time> </div> <h1 class="title"><span>令和最新Route Announcer事情</span></h1> <p>この記事は<a href="https://adventar.org/calendars/8589">yamanoku Advent Calendar 2023</a>の15日目の記事になります。</p> <h2 id="route-announcerとは何か">Route Announcerとは何か</h2>
<p>Single Page Application（以下SPA）は一枚のindex.htmlを元にJavaScript側の操作で画面遷移している風に見えるルーティングの実装をしています。このためスクリーンリーダーでは、サーバーサイドから次のページ情報を送ってくる方式では問題なかった画面遷移後の情報を検知することができません。つまりSPAでは今どの画面に行ったか、どの位置にいるかが分からず操作が混乱してしまう可能性があります。</p>
<p>この問題を解決するために<strong>Route Announcer</strong>（あるいはRoute Announcement）という仕組みが存在します。</p>
<p>Route Announcerのおおまかな仕組みはライブリージョンというものを活用し、画面内で動的な変化があった際にそれを支援技術へ伝えるというものです。具体的には、画面遷移の挙動が発生した際にライブリージョンに遷移先のページタイトルを伝えるようにすることで、支援技術側がそれを読み上げることができ、遷移したことが分かります。</p>
<p>Route Announcerを活用したフレームワークは<a href="https://www.gatsbyjs.com/">Gatsby</a>、<a href="https://nextjs.org/">Next.js</a>、<a href="https://kit.svelte.dev/">SvelteKit</a>、Angular（<a href="https://material.angular.io/cdk/a11y/overview#liveannouncer">Angular Material</a>）、<a href="https://astro.build/">Astro</a>が挙げられます。これらのフレームワークでのRoute Announcer挙動では、大見出し（<code>&#x3C;h1></code>）・ページタイトル（<code>&#x3C;title></code>）が存在する順から、フォールバックとしてページのURLが読み上げられます。</p>
<hr>
<p>ちなみにRoute Announcerの起源について調べてみたところ、Ember.jsの<a href="https://github.com/ember-a11y/a11y-announcer">a11y-announcer</a>がそれに相当するものかなと思っていました。ですが、さらに遡ると<a href="https://github.com/patrickfox/a11ykit">patrickfox/a11ykit</a>から相当する挙動を参考にしているみたいです。おそらくこれが始祖に当たるものかと思っていますが、もしこれよりも前に発明されたものやアイデアがあれば是非教えてください…！</p>
<h2 id="具体的な実装方法">具体的な実装方法</h2>
<p>次に具体的な実装方法に触れていきます。実装コードは「<a href="https://gihyo.jp/book/2023/978-4-297-13366-5">Webアプリケーションアクセシビリティ──今日から始める現場からの改善 WEB+DB PRESS</a>」より引用になります。</p>
<p>まずスクリーンリーダーに読み上げてもらう部分になります。</p>
<!-- prettier-ignore-start -->
<pre class="language-html" data-language="html"><code is:raw="" class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>p</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>announcer<span class="token punctuation">"</span></span> <span class="token attr-name">role</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>alert<span class="token punctuation">"</span></span> <span class="token attr-name">aria-live</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>assertive<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>p</span><span class="token punctuation">></span></span>
</code></pre>
<!-- prettier-ignore-end -->
<p><code>role="alert"</code>はユーザーに即座に重要かもしれないメッセージを通知させるためのWAI-ARIAのロールになります。</p>
<p><code>aria-live="assertive"</code>は要素の内容が変更された瞬間に読み上げるする指定です。この値には他にも読み上げない<code>off</code>という値と、すべての読み上げが終わった後に通知する<code>polite</code>があります。</p>
<p>仕様上では<code>role="alert"</code>には<code>aria-live="assertive"</code>を暗黙的に含んでいるため書く必要はないのですが、支援技術がすべて対応しているかはわからないため、ユーザーの環境を考慮して付与されている形になっています。</p>
<p>読み上げてもらう部分は視覚的には見えなくて良いので<a href="https://zenn.dev/yamanoku/scraps/a6c328ccc3238c">Visually Hidden</a>のスタイルを付与してあげます。</p>
<!-- prettier-ignore-start -->
<pre class="language-ts" data-language="ts"><code is:raw="" class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">onNavigationEnd</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> announcer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"announcer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> title <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'title'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>textContent<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>announcer <span class="token keyword">instanceof</span> <span class="token class-name">HTMLElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    announcer<span class="token punctuation">.</span>textContent <span class="token operator">=</span> title<span class="token punctuation">;</span>  <span class="token comment">// title要素のテキストを代入する</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<!-- prettier-ignore-end -->
<p>挙動については <code>onNavigationEnd</code>という関数を用意して、画面遷移が完了した際にこちらを呼び出すようにします。この関数では、<code>title</code>要素のテキストを取得してきて、要素のIDが<code>announcer</code>の中に代入しています。</p>
<p>これがRoute Announcerとして最低限必要な実装になります。実装を見て分かる通り<code>title</code>要素を取得してくるため、ページごとで適切な内容を設定しておくことが重要です。</p>
<h2 id="画面遷移後の挙動も考慮する">画面遷移後の挙動も考慮する</h2>
<p>Route Announcerの挙動は画面遷移の開始時に発火するものです。そのため画面遷移後の挙動についても考慮する必要があります。例えば画面遷移後にキーボード操作を上から始めたい場合は、ページ上部にフォーカス地点を移動させるようにする必要があります。</p>
<p>一番分かりやすい対応としては、画面遷移後にRoute Announcerにフォーカスを当てるというものがあります。</p>
<!-- prettier-ignore-start -->
<pre class="language-diff" data-language="diff"><code is:raw="" class="language-diff"><span class="token deleted-arrow deleted"><span class="token prefix deleted">&#x3C;</span><span class="token line">body>
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> &#x3C;p id="announcer" role="alert" aria-live="assertive">&#x3C;/p>
</span></span></code></pre>
<!-- prettier-ignore-end -->
<p>まずはRoute Announcer要素を<code>&#x3C;body></code>内での一番上に設置します。</p>
<!-- prettier-ignore-start -->
<pre class="language-diff" data-language="diff"><code is:raw="" class="language-diff"><span class="token deleted-arrow deleted"><span class="token prefix deleted">&#x3C;</span><span class="token line">p
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> id="announcer"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"> tabindex="-1"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> role="alert"
</span><span class="token prefix unchanged"> </span><span class="token line"> aria-live="assertive">
</span></span><span class="token deleted-arrow deleted"><span class="token prefix deleted">&#x3C;</span><span class="token line">/p>
</span></span></code></pre>
<!-- prettier-ignore-end -->
<p>読み上げる要素に<code>tabindex="-1"</code>を付与します。この値があることで<kbd>Tab</kbd>キーで順番に要素へフォーカス移動する際に、その要素だけをスキップできるようになります。</p>
<pre class="language-diff" data-language="diff"><code is:raw="" class="language-diff"><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> if (announcer instanceof HTMLElement) {
</span><span class="token prefix unchanged"> </span><span class="token line">   announcer.textContent = title;  // title要素のテキストを代入する
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">   announcer.focus();  // 読み上げる要素にフォーカスを当てる
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> }
</span></span></code></pre>
<p>テキストを代入後に<code>focus()</code>を使ってフォーカスを当てることができます。これによりSPAでの画面遷移後にはページ上部へとフォーカスが移動して、通常の画面遷移と同様にフォーカス順序が上から始められるようになります。</p>
<p>しかし、フォーカスの挙動としてはこの形で問題ないのですが、Windowsで使用できるスクリーンリーダー「<a href="https://www.nvda.jp/">NVDA</a>」での読み上げでは「<em>（ページタイトル）</em>、警告」というように読み上げられてしまいます。なぜそのように読みあげられてしまうかというと、スクリーンリーダーでは対応するHTMLの名前と役割を取得してくるため、<code>role="alert"</code>が付与されていることで「警告」という読み上げになります。</p>
<p>Route Announcer自体はSPAにおけるアクセシビリティ向上させる実装になりますが、あくまでもテクニックとしてのもので、HTMLの中における適切なセマンティクスな役割といったものは存在しません。なので<code>role</code>によっては違和感のある読み上げになってしまうこともあります。</p>
<p>それを加味するとセマンティクスな要素にフォーカス移動するのがスクリーンリーダー利用者にとっても理解しやすいのかなと思っています。<code>&#x3C;main></code>要素にフォーカスさせるというのも1つの手ですが、これはページ内コンテンツをすべて読み上げてしまうことにもつながってしまいます。</p>
<p>そのため読み上げる対象をより小さくさせたいと思っており、私の中で現時点で最適解と思っているのが<strong>ページ内の大見出し（あるいはページ内に準ずる見出し）にフォーカスさせる</strong>ことだと考えています。</p>
<!-- prettier-ignore-start -->
<pre class="language-ts" data-language="ts"><code is:raw="" class="language-ts"><span class="token keyword">const</span> <span class="token function-variable function">onNavigationEnd</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> headings <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">"h1, h2, h3, h4, h5, h6"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> focusHeading <span class="token operator">=</span> headings<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  headings<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>heading<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>heading<span class="token punctuation">.</span>tagName <span class="token operator">&#x3C;</span> focusHeading<span class="token punctuation">.</span>tagName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      focusHeading <span class="token operator">=</span> heading<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>focusHeading <span class="token keyword">instanceof</span> <span class="token class-name">HTMLElement</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    focusHeading<span class="token punctuation">.</span>tabIndex <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 見出しにtabindexを付与する</span>
    focusHeading<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 読み上げる要素にフォーカスを当てる</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<!-- prettier-ignore-end -->
<h2 id="navigation-apiへの期待">Navigation APIへの期待</h2>
<p>以上より私が現時点でもっている最適解は<strong>ページの大見出し（あるいはページ内に準ずる見出し）にフォーカスさせる</strong>だと思っているのですが、ページによってはレイアウトが異なったり、大見出しの位置が必ず保証されているわけでもありません。現状の対応ではレイアウトを固定するような制約をもたせない限りは完全には解決できないと思っています。</p>
<p>また、画面が遷移したかどうかはJavaScriptだけの管轄になっており、実装状況や利用環境によっては読み上げをしてくれるタイミングが変わる可能性もあるため、<code>setTimeout()</code>にてタイミングをズラす必要があったりします。</p>
<p>結局のところ共通で使えるRoute Announcerの実装は難しいというのが現状です。Ubieさんの事例<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>のように各プロダクトや各環境での状況に併せた実装が求められるのが現実です。</p>
<p>この独自で解決しなければならない問題に対しての銀の弾丸になりえると期待しているのが「<a href="https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigation-api">Navigation API</a>」です。こちらのAPIについてを<a href="https://jsconf.jp/2023/talk/yamanoku-1/">今年のJSConfJPでLTにて紹介させていただきました</a><sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup>。</p>
<p>Navigation APIは、<a href="https://developer.mozilla.org/ja/docs/Web/API/Location">Location API</a>や<a href="https://developer.mozilla.org/ja/docs/Web/API/History">History API</a>の後継として開発されている新しいWeb APIです。このAPIを利用することで、画面遷移の開始と終了のタイミングを通知することができたり、フォーカスマネジメントやスクロール位置の復元といったことも調整しやすくなります。</p>
<p>2023年現在ではChromeのみでしか使えないものですが、Interop 2024にてNavigation APIも<a href="https://github.com/web-platform-tests/interop/issues/435">相互運用に注力するAPIとして投票されております</a>。アクセシビリティ以外の観点でも各種ルーターライブラリにて活用ができそうなため期待が高まっています<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref="" aria-describedby="footnote-label">3</a></sup>。SPAでの画面遷移におけるアクセシビリティを大いに向上させてくれるWeb APIのため、早くクロスブラウザで実装されて、各スクリーンリーダーでも対応できるようになると良いなと思っています。</p>
<h2 id="参考情報">参考情報</h2>
<ul>
<li><a href="https://www.gatsbyjs.com/blog/2019-07-11-user-testing-accessible-client-routing/">What we learned from user testing of accessible client-side routing techniques with Fable Tech Labs | Gatsby</a></li>
<li><a href="https://qiita.com/24motz/items/a992a8d3d4b65452b7eb">スクリーンリーダーはどうやってライブリージョンを読み上げるのか - Qiita</a></li>
<li><a href="https://github.com/wicg/navigation-api">WICG/navigation-api</a></li>
<li><a href="https://developer.chrome.com/docs/web-platform/navigation-api/">Modern client-side routing: the Navigation API - Chrome for Developers</a></li>
<li><a href="https://blog.jxck.io/entries/2022-04-22/navigation-api.html">Navigation API による「JS での画面遷移」と SPA の改善 | blog.jxck.io</a></li>
<li><a href="https://zenn.dev/yend724/articles/20230817-1bpoplim35e6eeqi">View Transitions API と Navigation API でページ遷移アニメーションを実装してみる</a></li>
</ul>
<section data-footnotes="" class="footnotes"><h2 class="sr-only" id="footnote-label">脚注</h2>
<ol>
<li id="user-content-fn-1">
<p><a href="https://zenn.dev/ubie_dev/articles/499d3ecff708c0">SPA(Next.js)のスクリーンリーダーによる画面遷移で工夫したこと</a> <a href="#user-content-fnref-1" data-footnote-backref="" aria-label="コンテンツに戻る" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-2">
<p><a href="https://docs.google.com/presentation/d/e/2PACX-1vSosGMESLA5IiR4NPz3i2u8XF_wkHsqP80pHA1a4q-Gmk9CIFkUobNc5pMvJj6Tth0PEGmoExmalOQj/pub?slide=id.g29cfbd0e8bc_2_0">画面遷移のアクセシビリティ課題を解決しうる Navigation API への期待 - Google スライド</a> <a href="#user-content-fnref-2" data-footnote-backref="" aria-label="コンテンツに戻る" class="data-footnote-backref">↩</a></p>
</li>
<li id="user-content-fn-3">
<p><a href="https://github.com/remix-run/react-router/discussions/11046">ReactRouter</a>と<a href="https://github.com/TanStack/router/discussions/821">TanStack/router</a>とでNavigation APIに関するDiscussionsが登録されています <a href="#user-content-fnref-3" data-footnote-backref="" aria-label="コンテンツに戻る" class="data-footnote-backref">↩</a></p>
</li>
</ol>
</section> </article> <details> <summary>この記事に関する修正依頼</summary> <ul> <li> <a href="https://github.com/yamanoku/2023/issues/new?title=「令和最新Route Announcer事情」の修正依頼&labels=feedback&body=URL：https://2023.yamanoku.net/2023-12-15%0A修正依頼内容：%0A" target="_blank">
GitHub Issueを作成する
</a> </li> <li> <a href="https://twitter.com/intent/tweet?url=https://2023.yamanoku.net/2023-12-15&text=@yamanoku" target="_blank">
著者にポストする
</a> </li> </ul> </details> <a href="/">トップへ戻る</a> </main> <footer class="text-center"> <p>&copy; Copyright 2026, Okuto Oyama</p> <p>
Source :
<a href="https://github.com/yamanoku/2023/" target="_blank" rel="noopener">yamanoku/2023</a> </p> </footer> </body></html>